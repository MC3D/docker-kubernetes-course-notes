# Docker Commands

## `$ docker run <image name>`

When you execute `docker run <image name>`, Docker performs the following steps:

1. Checks if the specified image exists locally. If it doesn't, Docker tries to download the image from a configured registry (such as Docker Hub) unless specified otherwise.
2. Creates a new container based on the image.
3. Allocates necessary resources (CPU, memory, network, storage, etc.) for the container.
4. Starts the container and executes the default command specified in the image's Dockerfile or any custom command provided.

`docker run` = `docker create` + `docker start`

## `$ docker run <image name> [command]`

When you include a `[command]` at the end of the `docker run <image name>` command, it overrides (replaces) the default command specified in the Docker image and executes the provided command instead.

## `$ docker ps`

The `docker ps` command is used to list the currently running Docker containers on your system. It provides information about the containers such as their Container ID, Image, command being executed, creation time, status, and ports.

When you execute `docker ps`, it will display a table with the following columns:

- CONTAINER ID: A unique identifier for the container.
- IMAGE: The Docker image used to create the container.
- COMMAND: The command being executed within the container.
- CREATED: The time elapsed since the container was created.
- STATUS: The current status of the container (running, stopped, restarting, etc.).
- PORTS: The exposed ports of the container.
- NAMES: The automatically assigned (randomly generatred) or user-defined name of the container.

By default, `docker ps` only shows the running containers. If you want to see all containers (including the ones that have exited), you can use the `-a` or `--all` flag:

`$ docker ps -a`

You can use the command `docker container ls -a` as an alternative to `docker ps -a`.

## `$ docker create [options] <image name>`

The `docker create` command is used to create a new Docker container based on a specified image, but unlike `docker run`, it does not start the container immediately. Instead, it prepares the container and returns the Container ID of the newly created container.

Optional flags and parameters to customize the container's behavior, such as specifying environment variables, network settings, resource constraints, etc.

## `$ docker start <container id>`

After using `docker create`, you can later start the container using the `docker start` command, specifying the Container ID or container name.

By separating the creation and start of the container, you have more control and flexibility over container initialization, allowing you to configure additional options before actually running the container.

Note the difference between `docker start <container id>` and `docker start -a <container id>` lies in how the container's output is attached to the terminal.

`docker start <container id>`: The container's output is not attached to the terminal where the command is executed. It means that once the container starts, you won't see its output directly in your terminal. However, the container will continue running in the background.

`docker start -a <container id>`: The `-a` or `--attach` option is used to attach the container's output to the current terminal. When you use this option, the container's output is displayed in your terminal, allowing you to see the logs, console output, and any other information produced by the container.

## `$ docker system prune`

The `docker system prune` command is used to clean up unused Docker resources, including containers, images, networks, and volumes. It helps reclaim disk space and remove unnecessary artifacts left behind by previous Docker operations. When you execute docker system prune, the following actions occur:

1. Docker prompts you for confirmation before proceeding. You need to confirm the cleanup action by typing "y" or "yes" and pressing Enter.
2. Docker identifies and removes the following unused resources:

- Stopped containers: Containers that are not currently running.
- Unused images: Images that are not associated with any running container.
- Unused networks: Networks that are not connected to any container.
- Unused volumes: Volumes that are not being used by any container.

It's important to note that this command performs a potentially destructive operation, as it permanently deletes unused resources. Therefore, it's recommended to use it with caution and make sure you have a backup of any important data before running it.

## `$ docker logs <container id>`

The `docker logs <container id>` command is used to fetch the logs generated by a specific Docker container. When you execute this command, Docker retrieves and displays the logs associated with the container identified by `<container-id>`.

Here's how the `docker logs` command works:

1. Docker identifies the specified container based on its `<container-id>`. The container must be in a running or stopped state.
2. Docker retrieves the logs generated by the container, including the standard output (stdout) and standard error (stderr) streams.
3. The logs are displayed in the terminal or command prompt where the `docker logs` command was executed. By default, the logs are displayed in a continuous stream.

## `$ docker stop <container id>`

The `docker stop <container id>` command is used to stop a running Docker container. When you execute this command, Docker sends a SIGTERM signal to the main process running inside the container, giving it an opportunity to perform any necessary cleanup tasks before shutting down. If the process doesn't respond to the SIGTERM signal within a certain timeout period (default is 10 seconds), Docker sends a SIGKILL signal, forcefully terminating the container.

Here's how the `docker stop` command works:

1. Docker identifies the specified container based on its `<container id>`. The container must be in a running state.
2. Docker sends a SIGTERM signal to the main process inside the container, indicating that it should initiate the shutdown process.
3. The process running inside the container receives the SIGTERM signal and has a chance to perform any necessary cleanup tasks, such as saving data or closing connections gracefully.
4. If the process doesn't respond to the SIGTERM signal within the timeout period, Docker sends a SIGKILL signal, forcibly terminating the container. This ensures that the container stops even if the process doesn't exit gracefully.

## `$ docker kill <container id>`

The `docker kill <container id>` command is used to forcefully terminate a running Docker container. When you execute this command, Docker sends a SIGKILL signal to the main process running inside the container, immediately terminating it without giving the process a chance to perform any cleanup tasks.

Here's how the docker kill command works:

1. Docker identifies the specified container based on its `<container id>`. The container must be in a running state.
2. Docker sends a SIGKILL signal to the main process inside the container, indicating an immediate termination.
3. The process running inside the container is abruptly terminated, and the container stops without any further cleanup or graceful shutdown.

## `$ docker exec -it <container id> <command>`

The `docker exec -it <container id> <command>` command is used to execute a command within a running Docker container. It allows you to interact with the container's environment and run commands as if you were inside the container itself.

Here's how the docker exec command works with the `-it` options:

1. Docker identifies the specified container based on its <container id>. The container must be in a running state.
2. The `-it` options are used to allocate a pseudo-TTY (terminal) and establish an interactive session with the container. This enables you to enter commands and receive the output interactively.
3. `<command>` represents the command or series of commands you want to run inside the container. It can be any valid command available within the container's environment.
4. Docker starts a new process inside the running container, executing the specified command.
5. The output of the command is displayed in the terminal or command prompt from where you executed the docker exec command.

The `-i` and `-t` options in the `docker exec -it command` serve different purposes:

- `-i` (or `--interactive`): This option allows for an interactive connection with the container. It keeps the standard input (stdin) open, allowing you to provide input to the running command. Without the `-i` option, the command may not be able to receive interactive input. (allows for input)
- `-t` (or `--tty`): This option allocates a pseudo-TTY (terminal) for the command executed inside the container. It enables a terminal-like interface, formatting the output in a way that resembles an interactive shell session. The `-t` option is necessary to correctly display the output and make the command interaction more user-friendly. (input and output is formatted nicely)

## `$ docker exec -it <container id> sh`

The `docker exec -it <container id> sh` command is used to start an interactive session inside a running Docker container, specifically using the `/bin/sh` shell as the command interpreter. It allows you to enter commands and interact with the container's environment as if you were inside it.

Here's a breakdown of the command:

1. `docker exec`: This is the Docker command for executing a command within a running container.
2. `-it`: These options together allocate a pseudo-TTY (terminal) and establish an interactive session with the container. It enables the interactive input and output capabilities needed for an interactive session.
3. `<container id>`: This represents the ID or name of the running container in which you want to start the interactive session.
4. `sh`: It specifies the command to be executed inside the container. In this case, `sh` refers to the `/bin/sh` shell. You can replace `sh` with other available shells like `bash`, or `zsh` depending on the specific shell available in the container.
